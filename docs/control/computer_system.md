# 计算机组成
## CPU

![alt text](<src/Screenshot 2024-11-13 at 16.34.40.png>)

### 数据通路
**执行部件间传输信息的路径。**

建立由控制信号控制，受时钟驱动。

数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器。

数据通路中专门进行数据运算的部件称为执行部件或功能部件；数据通路由控制部件控制。

数据通路的功能是实现 CPU 内部的运算器与寄存器及寄存器之间的数据交换。

![alt text](<src/image copy.png>)

### 数据通路与总线结构

![alt text](<src/Screenshot 2024-11-13 at 17.07.10.png>)

### 总线结构与CPU指令周期

![alt text](<src/Screenshot 2024-11-25 at 18.53.45.png>)
![alt text](<src/Screenshot 2024-11-25 at 18.54.16.png>)

### CPU中的主要寄存器

**数据寄存器**（Data Register，DR）又称数据缓冲寄存器，其主要功能是作为CPU和主存、外设之间信息传输的中转站，用以弥补CPU和主存、外设之间操作速度上的差异。

数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一条指令或一个数据字时，也将它们暂时存放在数据寄存器中。

数据寄存器的作用是 ：

（1）作为CPU和主存、外围设备之间信息传送的中转站；

（2）弥补CPU和主存、外围设备之间在操作速度上的差异；

（3）在单累加器结构的运算器中，数据寄存器还可兼作操作数寄存器。

**指令寄存器**（Instruction Register，IR）用来保存当前正在执行的一条指令。

当执行一条指令时，首先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。

指令包括操作码和地址码两个字段，为了执行指令，必须对操作码进行测试，识别出所要求的操作，指令译码器（Instruction Decoder，ID）就是完成这项工作的。指令译码器对指令寄存器的操作码部分进行译码，以产生指令所要求操作的控制电位，并将其送到微操作控制线路上，在时序部件定时信号的作用下，产生具体的操作控制信号。

指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码，即可向操作控制器发出具体操作的特定信号。

**程序计数器**（Program Counter，PC）用来指出下一条指令在主存储器中的地址。

在程序执行之前，首先必须将程序的首地址，即程序第一条指令所在主存单元的地址送入PC，因此PC的内容即是从主存提取的第一条指令的地址。

当执行指令时，CPU能自动递增PC的内容，使其始终保存将要执行的下一条指令的主存地址，为取下一条指令做好准备。若为单字长指令，则(PC)+1àPC，若为双字长指令，则(PC)+2àPC，以此类推。

但是，当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段来指定，而不是像通常的那样通过顺序递增PC的内容来取得。

因此，程序计数器的结构应当是具有寄存信息和计数两种功能的结构。

**地址寄存器**（Address Register，AR）用来保存CPU当前所访问的主存单元的地址。

由于在主存和CPU之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。

当CPU和主存进行信息交换，即CPU向主存存入数据/指令或者从主存读出数据/指令时，都要使用地址寄存器和数据寄存器。

如果我们把外围设备与主存单元进行统一编址，那么，当CPU和外围设备交换信息时，我们同样要使用地址寄存器和数据寄存器。

**累加寄存器**通常简称累加器（Accumulator，AC），是一个通用寄存器。

累加器的功能是：当运算器的算术逻辑单元ALU执行算术或逻辑运算时，为ALU提供一个工作区，可以为ALU暂时保存一个操作数或运算结果。

**程序状态字**（Program Status Word，PSW）用来表征当前运算的状态及程序的工作方式。

程序状态字寄存器用来保存由算术/逻辑指令运行或测试的结果所建立起来的各种条件码内容，如运算结果进/借位标志（C）、运算结果溢出标志（O）、运算结果为零标志（Z）、运算结果为负标志（N）、运算结果符号标志（S）等，这些标志位通常用1位触发器来保存。

除此之外，程序状态字寄存器还用来保存中断和系统工作状态等信息，以便CPU和系统及时了解机器运行状态和程序运行状态。

因此，程序状态字寄存器是一个保存各种状态条件标志的寄存器。

## 存储器
 寄存器：制作在CPU中，其中数直接在CPU内部参与运算

 高速缓存cache：也制作在CPU中，速度快于内存，容量小于内存

 内存：存放将要参与运行的程序和数据，可以直接和CPU交换信息

 辅助存储器：用来存放暂时未用到的程序和数据文件，CPU不能直接访问辅存，辅存只能与主存交换信息

存储容量：存储字数 x 存储字长（如 1M x 8位 ）。
MAR反映存储字数，MDR反映了存储字长。

存储速度：数据传输率 = 数据的宽度/存储周期

存取时间：存取时间 + 恢复时间 = 存取周期，计算机进行一次读写操作后需要一段恢复时间才能进行下一次的读写操作。

主存带宽：就是上面的数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒，字节/秒，位/秒。
### 随机存储器RAM

DRAM芯片：使用栅极电容来存储信息

SRAM芯片：使用双稳态触发器来存储信息


 由于静态RAM是用触发器工作原理存储信息，因此即使信息读出后，它任保持其原状态，不需要再生。

 但掉电后原存信息丢失，故它属于易失性半导体存储器

动态RAM刷新

刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程

为什么需要刷新

    由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。
    所以必须采用定时刷新的方法，规定在一定时间内，对动态RAM全部基本单元电路必作一次刷新
    一般刷新周期为2ms
    刷新是一行一行的进行，必须在刷新周期内，用专门的刷新电路来完成对基本单元电路的逐行刷新

只读存储器的特点是只能读出而不能写入信息，通常在电脑主板的ROM里面固化
一个基本输入/输出系统，称为BIOS（基本输入输出系统）。其主要作用是完成对系统的加电自检、
系统中各功能模块的初始化、系统的基本输入/输出的驱动程序及引导操作系统。

由于DRAM存储容量较大，存储单元数目多，所需地址线也就比较多，为了简化硬件，采用地址线复用技术，行地址和列地址分成两次进行传送到译码器中。

### 存储芯片与CPU的连接

位扩展——增加存储字长

位扩展的关键就是将两个存储芯片当成一个存储芯片来用，让两个存储芯片同时工作，同时被选中，
同时做读操作，同时做写操作，要想保证同时，就是把两个芯片的片选CS，用相同的信号进行连接。

字扩展——增加存储字的数量

位扩展和字扩展 同时扩展

![alt text](<src/image copy 3.png>)

### 双端口RAM和多模块存储器

存取周期 = 存取时间 + 恢复时间

DRAM由于电容的特性，每次进行读操作后需要进行重写，也就是需要一定的恢复时间，导致DRAM的存取周期比较长，并且这个恢复时间往往还比存取时间长。

这两个问题分别对应接下来的内容：双端口RAM 和 多模块存储器。
![alt text](<src/image copy 2.png>)

高位交叉编址：每个存储体遍历完了之后再遍历下一个存储体。仅仅相当于扩容。

低位交叉编址：以横向方式遍历存储体，也就是每次都是遍历不同存储体的不同存储单元。这样，在读取其他存储体的存储单元时，之前读取过的存储单元可以利用这段时间进行恢复，达到一种并行的效果。

在模块数的选取上需要保证模块数 m >= T/r，这样才能保证存储体有足够的时间进行恢复。

### Cache

**空间局部性：** 在最近的未来要用到的信息，很有可能与正在使用的信息在存储空间上是临近的。（信息的存储一般都是顺序的）

**时间局部性：** 在最近的未来要用到的信息，很可能是现在正在使用的信息。（程序中很可能存在大量的循环结构，需要重复访问）

故Cache能够工作的理论依据：从上面两个局部性可以分析到，我们可以把CPU目前访问的地址周围的部分数据放到Cache中。

设 **tc**为访问一次Cache所需时间，**tm**为访问一次主存所需时间。

CPU能够直接在Cache中找到所需信息，称为命中。

**命中率 H：** CPU欲访问的信息已在Cache中的比率。

**缺失率（未命中率）M：** M = 1 - H

**CPU平均访问时间 t 为：** t = H tc + ( 1-H ) ( tc+tm )

将主存的存储空间进行分块，主存与Cache之间以块为单位进行数据交换。

这样主存地址就可分为两部分：块号 和 块内地址。

在操作系统中，通常将主存中的 “一个块” 也称为 “一个页/页面/页框” 。

Cache中的 “块” 也称为 “行” 。

Cache和主存之间仍然存在一些问题：

如何区分Cache和主存之间的数据块对应关系？ ——Cache和主存的映射方式

Cache很小，主存很大。如果Cache满了怎么办？ ——替换算法

CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性？ ——Cache写策略
### Cache和主存的映射方式
（1）全相联映射

任何一个主存块可以放在Cache的任意位置。

给每一个Cache块增加一个标记位，记录对应的主存块号。

还需要一个有效位，有效位为1时表示标记位有效，有效位为0时表示标记位无效。

优点：Cache存储空间利用充分，命中率高。

缺点：查找速度较慢

（2）直接映射

每个主存块只能放到特定的一个位置：Cache块号 = 主存块号 % Cache总块数。

于是对于Cache所保存的标记号可以不用保存主存中对应的整个地址，可以只保留主存块号m前面（m-n）个二进制数。

（3）组相联映射

将Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置。

每个主存块对应的组号 = 主存块号 % 分组数

### 替换算法
1.随机算法（RAND）

若Cache已满，则随机选择一块替换。

2.先进先出算法（FIFO）

若Cache已满，则替换最先被调入Cache的块。

3.近期最少使用（LRU）

为每一个Cache块设置一个”计数器“，用于记录每个Cache块已经多久没被访问过了。当Cache满了之后替换”计数器“最大的。

计数规则：

命中时，所命中的行的计数器清零，比其低的计时器加1，其余不变（加一没有意义）。

未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1。

未命中且没有空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。

4.最近不经常使用（LFU）

为每一个Cache块设置一个”计数器“，用于记录每个Cache块被访问过几次。当Cache满后替换“计数值”最小的。

新调入的块计数器=0，之后每被访问过一次计数器+1。

### Cache写策略
1.写命中

（1）写回法：

当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此Cache块被替换时才写回主存。

需要增加一位脏位，用于标记该Cache块是否被修改了。

减少了访存的次数，但存在数据不一致的隐患。

（2）全写法：

当CPU对Cache块写命中时，必须把数据同时写入Cache和主存中，一般使用写缓冲（write buffer）。

访存次数增加，速度变慢，但能保证数据的一致性。

2.写不命中
（1）写分配法：

当CPU对Cache写不命中时，把主存中的块调入Cache中，在Cache中修改，通常搭配写回法使用。
也就是发生替换时才写回主存。

（2）非写分配法：

当CPU对Cache写不命中时，只写入主存，不调入Cache中。搭配全写法使用。

![alt text](<src/image copy 4.png>)

### 虚拟存储系统
有时候一个程序比较大，无法将它顺序地存放在主存中的各个块中，因此操作系统会将它分成若干个页面，页面的大小和块的大小相同，每个页面可以离散地放入不同的主存块中。

逻辑地址（虚地址）：程序员看到的地址。

物理地址（实地址）：实际在主存中的地址。

对于一条机器指令：000001  001000000011（操作码+地址码），其地址码所使用的就是 逻辑地址。

页表：记录了每个逻辑页面存放在哪个主存块中，页表的数据放在主存中。

假设此时执行一条取指令操作，该指令为 000001 001000000011，所以要取的数据的逻辑地址为 001000000011

![alt text](<src/image copy 5.png>)

**虚拟存储系统：** 辅存中的数据并不是一次性全部加载到主存中的，而是和 Cache——主存 类似，根据局部性原理加载一部分数据到主存中。

